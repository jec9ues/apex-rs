use serde::{Deserialize, Serialize};

use std::error::Error;
use std::fmt::{Display, Formatter};
use std::fs::File;
use std::io::{BufReader, BufWriter, Write};
use std::net::Ipv4Addr;
use std::path::Path;
use inquire::{Confirm, CustomUserError, Select, Text};
use inquire::error::InquireResult;

#[derive(Debug, Serialize, Deserialize)]
pub struct Config {
    pub device: String,
    pub local_ip: Ipv4Addr,
    pub local_port: u16,
    pub remote_ip: Ipv4Addr,
    pub remote_port: u16,
}

pub fn read_config_from_file<P: AsRef<Path>>(path: P) -> Result<Config, Box<dyn Error>> {
    // Open the file in read-only mode with buffer.
    let file = File::open(path)?;
    let reader = BufReader::new(file);
    // Read the JSON contents of the file as an instance of `Config`.
    let u = serde_json::from_reader(reader)?;
    println!("Config -> {:?}", u);
    // Return the `Config`.
    Ok(u)
}

pub fn write_config_to_file<P: AsRef<Path>>(path: P, config: &Config) -> Result<(), Box<dyn Error>> {
    // Open the file in write-only mode with buffer.
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);

    // Serialize the `config` instance to JSON and write it to the file.
    let serialized_config = serde_json::to_string_pretty(config)?;
    writer.write_all(serialized_config.as_bytes())?;

    // Return Ok(()) indicating success.
    Ok(())
}


pub fn suggester(val: &str) -> Result<Vec<String>, CustomUserError> {
    let suggestions = [
        "-device fpga -memmap auto",
        "-device qemu://shm=qemu-win10.mem,qmp=/tmp/qmp-win10.sock",
        "ps: you can custom args <3",
    ];

    let val_lower = val.to_lowercase();

    Ok(suggestions
        .iter()
        .filter(|s| s.to_lowercase().contains(&val_lower))
        .map(|s| String::from(*s))
        .collect())
}
pub fn configure_config<P: AsRef<Path>>(path: P) -> Result<Config, Box<dyn Error>> {
    // Open the file in write-only mode with buffer.
    let file = File::create(path)?;

    let mut writer = BufWriter::new(file);

    let device = Text::new("Device args ->")
        .with_autocomplete(&suggester)
        .with_placeholder("1.fpga 2.kvm or you can configure your own")
        .prompt()?;

    let local_ip = Text::new("local ip ->")
        .with_placeholder("x.x.x.x")
        .prompt()?;

    let local_port = Text::new("local port ->")
        .with_placeholder("xxxxx")
        .prompt()?;

    let remote_ip = Text::new("remote ip ->")
        .with_placeholder("x.x.x.x")
        .prompt()?;

    let remote_port = Text::new("remote port ->")
        .with_placeholder("xxxxx")
        .prompt()?;

    let config: Config = Config {
        device,
        local_ip: local_ip.parse::<Ipv4Addr>()?,
        local_port: local_port.parse::<u16>()?,
        remote_ip: remote_ip.parse::<Ipv4Addr>()?,
        remote_port: remote_port.parse::<u16>()?,
    };
    println!("{:?}", config);
    // Serialize the `config` instance to JSON and write it to the file.
    let serialized_config = serde_json::to_string_pretty(&config)?;
    writer.write_all(serialized_config.as_bytes())?;

    // Return Ok(()) indicating success.
    Ok(config)
}



pub fn init_cfg() -> InquireResult<Config> {
    let ans: ConfigManage = Select::new("Initialize config:", ConfigManage::VARIANTS.to_vec()).prompt()?;

    let res = match ans {
        ConfigManage::NEW => {
            configure_config("cfg.json").unwrap()
        }
        ConfigManage::SAVED => {
            read_config_from_file("cfg.json").unwrap()
        }
        ConfigManage::CHECK => {
            let cfg = read_config_from_file("cfg.json").unwrap();
            let ans = Confirm::new("Continue or Break out?")
                .with_default(true)
                .with_help_message("Y for continue | N for break out")
                .prompt();
            match ans {
                Ok(true) => cfg,
                Ok(false) => panic!("break out configure"),
                Err(_) => panic!("break out configure"),
            }
        }
    };

    Ok(res)
}


#[derive(Debug, Copy, Clone)]
#[allow(clippy::upper_case_acronyms)]
enum ConfigManage {
    NEW,
    SAVED,
    CHECK
}

impl ConfigManage {
    // could be generated by macro
    const VARIANTS: &'static [ConfigManage] = &[
        Self::NEW,
        Self::SAVED,
        Self::CHECK,
    ];
}

impl Display for ConfigManage {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(f, "{self:?}")
    }
}
